# If agentOnly is true, will deploy only the agent
agentOnly: false

# If an admin user should be created during deployment
# Any previously created admin user will not be deleted
# when this is changed to false.
admin:
  create: true            # When set to false through a CLI override, the CLI must also include --no-login argument
  username: admin
  password: "my-password"

# Loft service options
service:
  type: ClusterIP
  # labels: {}            # {key: value} map of labels for the service
  # annotations: {}       # {key: value} map of annotations for the service

# Ingress options to use loft behind an ingress
ingress:
  enabled: false
  name: loft-ingress
  # labels: {}            # {key: value} map of labels for the ingress
  # annotations: {}       # {key: value} map of annotations for the ingress
  host: loft.mydomain.tld
  ingressClass: nginx
  path: /
  tls:
    enabled: true
    secret: loft-tls

# TLS configuration with a custom cert and key
# Make sure the secret exists prior to deploying loft,
# otherwise the loft pod will not be able to start
tls:
  enabled: false
  secret: loft-tls
  crtKey: tls.crt
  keyKey: tls.key

# Additional annotations for the loft deployment
# annotations: {}

# Additional labels for the loft deployment
# labels: {}

# Additional annotations for the loft pod
# podAnnotations: {}

# Additional common annotations for all resources
# commonAnnotations: {}

# Annotations for the loft-config secret
# secretAnnotations: {}

# Annotations for the loft-default-agent-values secret
# agentSecretAnnotations: {}

# Additional labels for the loft pod
# podLabels: {}

# Default values for loft deployment.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Default value is: ghcr.io/loft:{{ .Chart.Version }}
# Note: images prior to 3.1 use the docker.io/loftsh registry
# image: ghcr.io/loft-sh/loft

# Additional enviroment variables in the form of
# VAR_NAME: VAR_VALUE
env: {}

# Additional environment variables in the form of
# VAR_NAME:
#   secretKeyRef:
#     name: mysecret
#     key: username
envValueFrom: {}

# Replica amount of the loft deployment
replicaCount: 1

# Deployment strategy to be used for rolling out new replicasets
# strategy:
#   type: RollingUpdate

# Resources of the loft deployment
resources:
  requests:
    cpu: 750m
    memory: 1Gi
  limits:
    cpu: "4"
    memory: 4Gi

# Additional volumes that should be mounted to the loft deployment
volumes: []

# Additional volume mounts that should be mounted into the loft container
volumeMounts: []

# If the readinessProbe should be enabled
readinessProbe:
  enabled: true

# If the livenessProbe should be enabled
livenessProbe:
  enabled: true

# If an extension api service should be registered for
# the loft apis in kubernetes
apiservice:
  create: true

# Additional loft service account options
serviceAccount:
  name: loft
  create: true
  clusterRole: cluster-admin
  imagePullSecrets: []
  annotations: {}

# If a cert issuer should be created for loft
certIssuer:
  create: false
  email: "" # This is a required field if create == true
  name: lets-encrypt-http-issuer
  secretName: loft-letsencrypt-credentials
  server: https://acme-v02.api.letsencrypt.org/directory
  httpResolver:
    enabled: true
    ingressClass: nginx
  resolvers: []

# Persistence options
persistence:
  enabled: false
  size: 30Gi
  # Optional storage class
  #storageClassName: my-storage-class
  # Optional custom accessModes
  #accessModes: ["ReadWriteOnce"]

# Additional options for audit logging
audit:
  enableSideCar: false
  image: library/alpine:3.13.1
  # Deprecated, use persistence instead
  persistence:
    enabled: false
    size: 10Gi
    # Optional storage class
    #storageClassName: my-storage-class
    # Optional custom accessModes
    #accessModes: ["ReadWriteOnce"]
  securityContext:
    allowPrivilegeEscalation: false
    privileged: false
    capabilities:
      drop:
        - ALL
    runAsNonRoot: true
    runAsUser: 1000

# Prometheus Service Monitor Configuration
serviceMonitor:
  enabled: false
  jobLabel: loft
  targetPort: 8080
  path: /metrics
  interval: 60s
  scrapeTimeout: 30s
  labels: {}

# Loft config to use, all options can be seen at:
# https://loft.sh/docs/admin/config
config:
  audit:
    enabled: true

# Enables running loft agent with a security context that:
# - disables privileged escalation
# - drops all capabilities
# - runs as non-root
securityContext:
  # DEPRECATED: enabled field is deprecated, please use only fields valid for pod.spec.containers.securityContext here
  enabled: true
  allowPrivilegeEscalation: false
  privileged: false
  capabilities:
    drop:
      - ALL
  runAsNonRoot: true

# Sets pod security context for loft
# Example:
# podSecurityContext:
#   fsGroup: 2000
podSecurityContext: {}

# Loft *agent* default values to use, options can be seen in the loft-agent chart values:
# https://github.com/loft-sh/loft/blob/main/chart/values.yaml
# If loft.sh/agent-values annotation is set, then all these values are ignored
agentValues: {}

# if the webhook should be deployed
webhook:
  create: true

# host aliases to use for the deployment
hostAliases: []

# Configures structured logging within Loft
logging:
  encoding: console # Can be either json or console
  level: info # Can be either: debug, info, error

# The product to use
product: loft

# Token is used to connect to the network peer coordinator server of a Loft instance
token: ""
# URL is used to connect as the endpoint of the network peer coordinator server
url: ""

# AdditionalCA is used to add an additional CA certificate to the application's
# x509 root ca verification flow. Needs to be base64 encoded.
additionalCA: ""

# insecureSkipVerify is used to omit tls verification within loft and all its
# managed components
insecureSkipVerify: false

podDisruptionBudget:
  ## Specifies whether a Pod disruption budget should be created
  ##
  create: true
  minAvailable: 1
  # maxUnavailable: 1

affinity:
  # podAffinity section from Kubernetes Pod's spec.affinity.podAffinity
  podAffinity: {}

  # podAffinity section from Kubernetes Pod's spec.affinity.podAntiAffinity
  podAntiAffinity: {}

  nodeAffinity:
    preferNotToRunOnSpotInstances:
      # If enabled, node anti-affinities are added to pods to prefer not to run on spot instances. This works on
      # Google Kubernetes Engine, Azure Kubernetes Service and AWS Elastic Kubernetes Service Classic
      # (only EKS managed nodes, not EKS auto-mode).
      enabled: false

      # The terms used to create node anti-affinities for spot instances
      terms:
        - weight: 50
          preference:
            matchExpressions:
              - key: eks.amazonaws.com/capacityType
                operator: NotIn
                values:
                  - SPOT
              - key: kubernetes.azure.com/scalesetpriority
                operator: NotIn
                values:
                  - spot
              - key: cloud.google.com/gke-provisioning
                operator: NotIn
                values:
                  - spot

    # preferredDuringSchedulingIgnoredDuringExecution is the Kubernetes Pod's
    # spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution section
    preferredDuringSchedulingIgnoredDuringExecution: []
#      - weight: 70
#        preference:
#          matchExpressions:
#            - key: some/key
#              operator: NotIn
#              values:
#                - value1

    # requiredDuringSchedulingIgnoredDuringExecution is the Kubernetes Pod's
    # spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution section.
    requiredDuringSchedulingIgnoredDuringExecution: {}
#      nodeSelectorTerms:
#        - matchExpressions:
#            - key: some/key
#              operator: In
#              values:
#                - value1
#                - value2

