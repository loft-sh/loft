---
title: Configure Domain & TLS For Loft (Optional)
sidebar_label: 1.2 Domain & TLS (Optional)
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Flow, { Step } from '@site/src/components/Flow'
import Label from '@site/src/components/Label'
import Expander from '@site/src/components/Expander'

import PartialAdminSetVersion from '../admin/_partials/set-version.mdx'
import PartialAdminUpgrade from '../admin/_partials/upgrade.mdx'


:::caution Remote Cluster Required
Connecting a domain requires that you have deployed Loft to a remote cluster.
:::

After installing Loft, you may also choose to configure Domain and Transport Layer Security (TLS). Configuring Domain and TLS enables you to use Loft together with other members of your team who do not have direct access to Kubernetes, but want a common trusted endpoint for their Loft instance.

## Configure Domain

<details>
  <summary>

### NGINX Ingress Controller

  </summary>

<Tabs
  defaultValue="auto"
  values={[
    { label: 'Automatic or Existing Installation', value: 'auto', },
    { label: 'Manual Ingress Controller Installation', value: 'manual', },
  ]
}>
<TabItem value="auto">

<Flow id="nginx-ingress-automatic-install">
  <Step>

Run the command:
```yaml
loft start --host=loft.mydomain.tld     # Make sure to change `loft.mydomain.tld`
```

  </Step>
  <Step>
    <PartialAdminSetVersion/>
  </Step>
  <Step>
    <PartialAdminUpgrade/>
  </Step>
  <Step>

Determine the External-IP address:
```
kubectl get ingress -n loft
NAME           CLASS    HOSTS                ADDRESS          PORTS     AGE
loft-ingress   <none>   loft.mydomain.tld    x.x.x.x          80, 443   10m
```

  </Step>
  <Step>

[Set up a DNS A record](https://www.google.com/search?q=set+up+a+record+dns) to the ingress address (x.x.x.x). Make sure Loft is reachable at the address via:

```
curl https://loft.mydomain.tld/version --insecure
{"kind":"Version","apiVersion":"version.loft.sh","metadata":{"creationTimestamp":null},"version":"v1.15.0","major":"1","minor":"15","instance":"","kubeVersion":"v1.21.3-gke.2001"}
```

  </Step>
</Flow>

</TabItem>
<TabItem value="manual">

<Flow id="nginx-ingress-manual-install">
  <Step>

Deploy `nginx-ingress` controller to your cluster:
```bash
helm upgrade --install ingress-nginx ingress-nginx --repository-config='' \
  -n ingress-nginx --create-namespace \
  --repo https://kubernetes.github.io/ingress-nginx \
  --set-string controller.config.hsts=false \
  --wait
```

  </Step>
  <Step>

Determine the External-IP address:
```
kubectl get ingress -n loft
NAME           CLASS    HOSTS                ADDRESS          PORTS     AGE
loft-ingress   <none>   loft.mydomain.tld    x.x.x.x          80, 443   10m
                                             ^^^^^^^
```

  </Step>
  <Step>

[Set up a DNS A record](https://www.google.com/search?q=set+up+a+record+dns) to the ingress address (x.x.x.x). Make sure Loft is reachable at the address via:

```
curl https://loft.mydomain.tld/version --insecure
{"kind":"Version","apiVersion":"version.loft.sh","metadata":{"creationTimestamp":null},"version":"v1.15.0","major":"1","minor":"15","instance":"","kubeVersion":"v1.21.3-gke.2001"}
```

  </Step>
  <Step>

Edit your existing `loft.yaml` file or create a new file named `loft.yaml` with the following content:
```yaml
ingress:
  enabled: true
  host: "loft.mydomain.tld"   # Make sure to change this
  ingressClass: "nginx"       # Optional
```

  </Step>
  <Step>
    <PartialAdminSetVersion/>
  </Step>
  <Step>
    <PartialAdminUpgrade/>
  </Step>
</Flow>

</TabItem>
</Tabs>

</details>

<details>
  <summary>

### Load Balancer

  </summary>

<Flow id="domain-lb">
  <Step>

Create a file named `loft-loadbalancer.yaml` with the following content:

<Tabs
  defaultValue="elb"
  values={[
    { label: 'AWS ELB + ACM', value: 'elb', },
    { label: 'Other Load Balancers', value: 'other', },
  ]
}>
<TabItem value="elb">

```yaml {5-6}
apiVersion: v1
kind: Service
metadata:
  annotations:
    # Make sure to adjust the next line:
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:eu-west-2:xxx:certificate/xxx"
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
  name: loft-loadbalancer
  namespace: loft
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 80
  - name: https
    port: 443
    protocol: TCP
    targetPort: 80
  selector:
    app: loft
    release: loft
```

</TabItem>
<TabItem value="other">

```yaml
apiVersion: v1
kind: Service
metadata:
  name: loft-loadbalancer
  namespace: loft
spec:
  type: LoadBalancer
  ports:
    - name: https
      port: 443
      targetPort: 443
      protocol: TCP
  selector:
    app: loft
    release: loft
```

</TabItem>
</Tabs>

  </Step>
  <Step>

Create the load balancer with this command:
```
kubectl apply -f loft-loadbalancer.yaml
```

  </Step>
  <Step>

Wait until the load balancer receives an External-IP address:
```
kubectl get svc loft-loadbalancer -n loft
NAME                    TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)          AGE
loft-loadbalancer       LoadBalancer   10.112.2.142    x.x.x.x          443:30933/TCP    3m16s
                                                       ^^^^^^^
```

  </Step>
  <Step>

Make sure Loft is reachable at the external ip address via:
```
curl https://x.x.x.x/version --insecure
{"kind":"Version","apiVersion":"version.loft.sh","metadata":{"creationTimestamp":null},"version":"v1.15.0","major":"1","minor":"15","instance":"","kubeVersion":"v1.21.3-gke.2001"}
```

  </Step>
</Flow>

</details>

:::caution AWS Load Balancers
If you are using AWS, make sure you are using a Network Load Balancer (NLB) to route traffic, since other load balancers do not support the SPDY protocol Kubernetes requires.
:::



## Configure TLS

<details>
  <summary>

### Cert-Manager

  </summary>

<Flow id="cert-manager">
  <Step>

Install `cert-manager` to your cluster:
```bash
helm upgrade --install  cert-manager cert-manager  --repository-config=''\
  --namespace cert-manager  --create-namespace \
  --repo https://charts.jetstack.io \
  --set installCRDs=true \
  --wait
```

  </Step>
  <Step>

Edit your existing `loft.yaml` file, or create a new file named `loft.yaml` with content:
```yaml {3-4}
ingress:
  annotations:
    # Make sure the following line matches the name of your issuer (or use the section below to create one)
    cert-manager.io/cluster-issuer: lets-encrypt-http-issuer
  tls:
    enabled: true
    secret: tls-loft

certIssuer:
  create: true                                      # Change this if you already have your own cert-issuer
  name: lets-encrypt-http-issuer
  email: "YOUR_EMAIL"                               # REQUIRED
  secretName: loft-letsencrypt-credentials
  httpResolver:
    enabled: true
    ingressClass: nginx
  resolvers: []
  server: https://acme-v02.api.letsencrypt.org/directory
```

  </Step>
  <Step>
    <PartialAdminSetVersion/>
  </Step>
  <Step>
    <PartialAdminUpgrade/>
  </Step>
</Flow>

</details>

<details>
  <summary>

### AWS Certificate Manager (ACM)

  </summary>

<Tabs
  defaultValue="ingress"
  values={[
    { label: 'Domain via Ingress', value: 'ingress', },
    { label: 'Domain via Load Balancer', value: 'lb', },
  ]
}>
<TabItem value="ingress">

<Flow id="acm-ingress">
  <Step>

Determine the External-IP address of your ingress:
```
kubectl get ingress -n loft
NAME           CLASS    HOSTS                ADDRESS          PORTS     AGE
loft-ingress   <none>   loft.mydomain.tld    x.x.x.x          80, 443   10m
                                             ^^^^^^^
```

  </Step>
  <Step>

Find the AWS Elastic Load Balancer(ELB) for this IP address in the AWS console

  </Step>
  <Step>

Switch to the tab `Listeners`

  </Step>
  <Step>

In the column "SSL Certificates", click on the link `View/edit certificates`

  </Step>
  <Step>

Click on the `+` Synbol next to the tab `Certificates` and add your Access Control Manager (ACM) managed certificate to the ingress controller's Load Balancer

  </Step>
</Flow>

</TabItem>
<TabItem value="lb">

Make sure to follow the [Load Balancer > AWS ELB + ACM](#1-configure-domain) guide above.

</TabItem>
</Tabs>

</details>

<details>
  <summary>

### Manually Provisioned Certificate

  </summary>

<Flow id="cert-manual">
  <Step>

Create a Kubernetes secret from your certificate:
```bash
kubectl create secret generic tls-loft -n loft --type=kubernetes.io/tls \
  --from-file=tls.crt=tls.crt \
  --from-file=tls.key=tls.key
```

  </Step>
  <Step>

Edit your existing `loft.yaml` file, or create a new file named `loft.yaml` with content:

<Tabs
  defaultValue="ingress"
  values={[
    { label: 'Loft Ingress handles TLS', value: 'ingress', },
    { label: 'Loft Pod handles TLS', value: 'loft', },
    { label: 'Load Balancer handles TLS', value: 'lb', },
  ]
}>
<TabItem value="ingress">

```yaml
ingress:
  tls:
    enabled: true
    secret: tls-loft      # Make sure this matches the name of your cert from the previous step
```

</TabItem>
<TabItem value="loft">

```yaml
tls:
  enabled: true
  secret: tls-loft      # Make sure this matches the name of your cert from the previous step
```

</TabItem>
<TabItem value="lb">

This must be configured outside of the Loft deployment

</TabItem>
</Tabs>

  </Step>
  <Step>
    <PartialAdminSetVersion/>
  </Step>
  <Step>
    <PartialAdminUpgrade/>
  </Step>
</Flow>

</details>

<details>
  <summary>

### Self-Signed Certificate

  </summary>

<Flow id="cert-self-signed">
  <Step>

Create a new private key:
```
openssl genrsa -out tls.key 4096
```

  </Step>
  <Step>

Create a file named `ssl.conf` with the following content:
``` {9-12,26-27}
[ req ]
default_bits       = 4096
distinguished_name = req_distinguished_name
x509_extensions    = v3_ca
req_extensions     = v3_req
x509_extensions    = usr_cert

[ req_distinguished_name ]
organizationName          = Organization Name (eg, company)
organizationName_default  = loft
commonName                = Common Name (e.g. server FQDN or YOUR name)
commonName_default        = loft.mydomain.tld

[ usr_cert ]
basicConstraints  = CA:FALSE
nsCertType        = client, server
keyUsage          = digitalSignature
extendedKeyUsage  = serverAuth, clientAuth

[ v3_req ]
subjectAltName   = @alt_names
extendedKeyUsage = serverAuth, clientAuth
basicConstraints = CA:FALSE
keyUsage         = digitalSignature

[ alt_names ]
DNS.1 = localhost
```

  </Step>
  <Step>

Create a certificate signing request:
```bash
openssl req -new -sha256 \
    -out tls.csr \
    -key tls.key \
    -config ssl.conf
```

  </Step>
  <Step>

Generate the certificate:
```bash
openssl x509 -req \
    -sha256 \
    -days 3650 \
    -in tls.csr \
    -signkey tls.key \
    -out tls.crt \
    -extensions v3_req \
    -extfile ssl.conf
```

  </Step>
  <Step>

Create a Kubernetes secret from your certificate:
```bash
kubectl create secret generic tls-loft -n loft --type=kubernetes.io/tls \
  --from-file=tls.crt=tls.crt \
  --from-file=tls.key=tls.key
```

  </Step>
  <Step>

Edit your existing `loft.yaml` file, or create a new file named `loft.yaml` with content:

<Tabs
  defaultValue="ingress"
  values={[
    { label: 'Loft Ingress handles TLS', value: 'ingress', },
    { label: 'Loft Pod handles TLS', value: 'loft', },
    { label: 'Load Balancer handles TLS', value: 'lb', },
  ]
}>
<TabItem value="ingress">

```yaml
ingress:
  tls:
    enabled: true
    secret: tls-loft      # Make sure this matches the name of your cert from the previous step
```

</TabItem>
<TabItem value="loft">

```yaml
tls:
  enabled: true
  secret: tls-loft      # Make sure this matches the name of your cert from the previous step
```

</TabItem>
<TabItem value="lb">

This must be configured outside of the Loft deployment

</TabItem>
</Tabs>

  </Step>
  <Step>
    <PartialAdminSetVersion/>
  </Step>
  <Step>
    <PartialAdminUpgrade/>
  </Step>
</Flow>

</details>
